unit FILESYSTEMBLOCKACCESSINTERFACE;
{**************************************************************************}
{                                                                          }
{    This C DLL header file first (automatic) conversion generated by:     }
{    HeadConv 4.0 (c) 2000 by Bob Swart (aka Dr.Bob - www.drbob42.com)     }
{      Final Delphi-Jedi (Darth) command-line units edition                }
{                                                                          }
{    Generated Date: 02/06/2003                                            }
{    Generated Time: 11:11:55                                              }
{                                                                          }
{**************************************************************************}

interface
uses
{$IFDEF WIN32}
  Windows;
{$ELSE}
  Wintypes, WinProcs;
{$ENDIF}


{=> NeroFileSystemManager\FILESYSTEMBLOCKACCESSINTERFACE.H <=}

{+//***************************************************************************** }
{-|* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF }
{-|* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO }
{-|* THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A }
{-|* PARTICULAR PURPOSE. }
{-|* }
{-|* Copyright 1995-2003 Ahead Software AG. All Rights Reserved. }
{-|*----------------------------------------------------------------------------- }
{-|* NeroSDK / NeroAPI }
{-|* }
{-|* PROGRAM: FileSystemBlockAccessInterface.h }
{-|* }
{-|* PURPOSE: The file system block access interface }
{-|* The NeroAPI packet writing API will return INeroFileSystemBlockAccess that }
{-|* can be used to have block access to a file system. }
{=***************************************************************************** }
{$IFNDEF FILESYSTEMBLOCKACCESSINTERFACE_H}
{$DEFINE FILESYSTEMBLOCKACCESSINTERFACE_H}

{$INCLUDE "FileSystemBlockWriterInterface.h"}
{$INCLUDE "FileSystemBlockAccessExtensions.h"}

{+// This interface contains an extension scheme that will allow us to }
{-* transparently extend the interface's functionality without losing binary }
{-* compatibility. }
{= }
{/// Returns the number of supported extension fields }
var
  GetNumSupportedExtensions: function: VIRTUAL cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
{/// In combination with the method above, this method can be used to copy a set of extensions }
{/// without knowing which ones are actually there. Extensions have to be passed through to }
{/// any of the Nero filesystem generators, so it is essential to have some means of copying them }
var
  GetFileExtensionByNumber: function(iNumExt: var Integer): VIRTUAL INEROFILESYSTEMBLOCKACCESSEXTENSION cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
{/// Returns specified extension or NULL if not present }
var
  GetFileExtension: function(eExtType: var NEROFSBLOCKACCESSEXTENSIONSTYPE): VIRTUAL INEROFILESYSTEMBLOCKACCESSEXTENSION cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 



{$ENDIF // FILESYSTEMBLOCKACCESSINTERFACE_H}

var
  DLLLoaded: Boolean { is DLL (dynamically) loaded already? }
    {$IFDEF WIN32} = False; {$ENDIF}

implementation

var
  SaveExit: pointer;
  DLLHandle: THandle;
{$IFNDEF MSDOS}
  ErrorMode: Integer;
{$ENDIF}

  procedure NewExit; far;
  begin
    ExitProc := SaveExit;
    FreeLibrary(DLLHandle)
  end {NewExit};

procedure LoadDLL;
begin
  if DLLLoaded then Exit;
{$IFNDEF MSDOS}
  ErrorMode := SetErrorMode($8000{SEM_NoOpenFileErrorBox});
{$ENDIF}
  DLLHandle := LoadLibrary('FILESYSTEMBLOCKACCESSINTERFACE.DLL');
  if DLLHandle >= 32 then
  begin
    DLLLoaded := True;
    SaveExit := ExitProc;
    ExitProc := @NewExit;
    @GetNumSupportedExtensions := GetProcAddress(DLLHandle,'GetNumSupportedExtensions');
  {$IFDEF WIN32}
    Assert(@GetNumSupportedExtensions <> nil);
  {$ENDIF}
    @GetFileExtensionByNumber := GetProcAddress(DLLHandle,'GetFileExtensionByNumber');
  {$IFDEF WIN32}
    Assert(@GetFileExtensionByNumber <> nil);
  {$ENDIF}
    @GetFileExtension := GetProcAddress(DLLHandle,'GetFileExtension');
  {$IFDEF WIN32}
    Assert(@GetFileExtension <> nil);
  {$ENDIF}
  end
  else
  begin
    DLLLoaded := False;
    { Error: FILESYSTEMBLOCKACCESSINTERFACE.DLL could not be loaded !! }
  end;
{$IFNDEF MSDOS}
  SetErrorMode(ErrorMode)
{$ENDIF}
end {LoadDLL};

begin
  LoadDLL;
end.
