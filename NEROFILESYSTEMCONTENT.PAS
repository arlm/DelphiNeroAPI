unit NEROFILESYSTEMCONTENT;
{**************************************************************************}
{                                                                          }
{    This C DLL header file first (automatic) conversion generated by:     }
{    HeadConv 4.0 (c) 2000 by Bob Swart (aka Dr.Bob - www.drbob42.com)     }
{      Final Delphi-Jedi (Darth) command-line units edition                }
{                                                                          }
{    Generated Date: 02/06/2003                                            }
{    Generated Time: 11:10:31                                              }
{                                                                          }
{**************************************************************************}

interface
uses
{$IFDEF WIN32}
  Windows;
{$ELSE}
  Wintypes, WinProcs;
{$ENDIF}


{=> NEROFILESYSTEMCONTENT.H <=}

{+//***************************************************************************** }
{-|* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF }
{-|* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO }
{-|* THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A }
{-|* PARTICULAR PURPOSE. }
{-|* }
{-|* Copyright 1995-2003 Ahead Software AG. All Rights Reserved. }
{-|*----------------------------------------------------------------------------- }
{-|* NeroSDK / NeroAPI }
{-|* }
{-|* PROGRAM: NeroFileSystemContent.h }
{-|* }
{-|* PURPOSE: }
{-|* This is the third NeroAPI interface for preparing data CDs/DVDs. Unlike NeroIsoTrack.h, }
{-|* it is not much "callback based",thus most of the process will be driven by the }
{-|* application, making it easier to write. This interface is closely connected to the }
{-|* internal engine of NeroAPI, this improves the cooperation of NeroAPI and the application. }
{-|* }
{-|* This set of classes describe the content of the file system of a disc. }
{-|* The application will build a file structure using the IFileSystemContent object. }
{-|* During the burn process, NeroAPI will request the content of files using the }
{-|* IFileContent interface. }
{-|* }
{-|* Use the NeroCreateFileSystemContainer function of NeroAPI.h to get an instance of an }
{-|* IFileSystemDescContainer object. Then, use the NERO_WRITE_FILE_SYSTEM_CONTAINER structure }
{-|* to burn the file structure created. }
{=***************************************************************************** }
{$IFNDEF __NEROFILESYSTEMCONTENT_H}
{$DEFINE __NEROFILESYSTEMCONTENT_H}

{/// To make sure we do not interfere with other classes }

{/// loosing binary compatibility. Returns NULL if no interface with this ID was found }
{/// This is inspired from the COM QueryInterface function }
var
  GetOtherInterface: function(interfaceId: Integer) cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  GetOtherInterface: function(const interfaceName: PChar) cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 

var
  ~InterfaceBase: var function: ROTECTED: VIRTUAL cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 

{///////////////////////////////////////////////////////////////////////////////////////// }
{/// This first set of interfaces will be used by the burn engine to read the content of }
{/// the file system }
{///////////////////////////////////////////////////////////////////////////////////////// }

var
  Read: function(pBuffer: Pointer; 
                 length: var Word): UBLIC: VIRTUAL UNSIGNED cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  EndOfFile: function: VIRTUAL cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  Error: function: VIRTUAL cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 

{/// Called by the application when the object is not needed anymore }
var
  Release: function cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 


type
  ENTRY_ERROR = (
    ENTRY_NO_ERROR, 
    SEQUENCING_ERROR, 
    ERROR_NOT_A_FILE, 
    NOT_AVAILABLE, 
    INTERFACE_ERROR, 
    FEATURE_NOT_AVAILABLE  );

type
  IFileSystemDescContainer : public IFileSystemContent = (
    MODE2_FORM2 {=1<<0}, 
    FIXED_INSIDE_VOLUME_SPACE {=1<<1}, 
    FIXED_OUTSIDE_VOLUME_SPACE {=1<<2}, 
    NO_OWN_CONTENT {=1<<3 } );

var
  GetName: function: PVIRTUAL CONST CHAR cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 

var
  GetSubDirectory: var function: VIRTUAL CONST IDIRECTORY cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  GetContent: function(var *: IFILECONTENT*): VIRTUAL cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  GetSourceFilePath: var function: VIRTUAL CONST CHAR cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  GetSize: function: VIRTUAL cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  GetFilePriority: function: VIRTUAL cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  GetDirOrder: function: VIRTUAL cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  GetId: function: VIRTUAL cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  GetDataStartSec: function: VIRTUAL cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 

var
  GetNumEntries: var function: UBLIC: VIRTUAL INT cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  GetDirectoryEntry: function(i: var Integer): VIRTUAL CONST IDIRECTORYENTRY cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 


var
  GetName: var function: PUBLIC: VIRTUAL CONST CHAR cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  GetRoot: var function: VIRTUAL CONST IDIRECTORY cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 


{///////////////////////////////////////////////////////////////////////////////////////// }
{/// This second set of interfaces will be used by the application to produce the content of }
{/// the file system }
{///////////////////////////////////////////////////////////////////////////////////////// }


{/// Allows the file producer to return the data }
var
  Write: function(const buffer: Pointer; 
                  size: Integer) cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 

{/// Produce the content of a file. This interface must be derived and its implementation must }
{/// create the content of the file in the ProduceFile function }
{/// delivered by the producer }
var
  ProduceFile: function(var str: IDATAINPUTSTREAM): VIRTUAL cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 

{/// Called by NeroAPI when the object is not needed anymore }
var
  Release: function cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 



{/// Description of a file }
type
  IFileSystemDescContainer : public IFileSystemContent = (
    IID_IDirectoryEntryContainer, 
    IID_IFileProducer, 
    {/// object, 
    this one can be retrieved using GetOtherInterface  );

{/// Using this function, the file size can be changed after having added the entry to the directory }
var
  SetSize: function(size: __INT64) cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 

{/// The two functions below can be used to readjust the directory priority }
{/// Priority numbers will be used in upward order: the file with smaller values first }
var
  SetPriority: function(priority: Integer) cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  SetDirOrder: function(directoryPriority: Integer) cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 

{/// Set the sector number that will be saved into the directory structure }
var
  SetDataStartSec: function(_1: Word) cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 

{/// Set the physical position of the file in the filesystem }
var
  SetFixedDataStartSec: function(_1: Word) cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 

var
  SetFileNumber: function(_1: Integer) cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  SetId: function(_1: Integer) cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  SetFlags: function(enable: Bool; 
                     f: Word) cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 

{/// Extension of the IDirectoryEntryContainer interface }
var
  GetFileProducer: var function: VIRTUAL CONST IFILEPRODUCER cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 

{/// Update the size attribute of this file by producing its content without writing }
{/// it anywhere }
var
  MeasureSize: function: VIRTUAL cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 

{/// Set the size that is stored in the media directory record but do not change the }
{/// size of allocated and requested data }
{/// This is currently only available for ISO filesystems }
var
  SetDirRecordSize: function(size: __INT64): VIRTUAL cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 


{/// Represents the content of a directory }
{/// directoryPriority specifies the position in the directory. See this->AddFile }
{/// for details }
var
  AddDirectory: function(const name: PChar; 
                         directoryPriority: var Integer): VIRTUAL IDIRECTORYCONTAINER cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 

{/// Add a file the directory. The fp object will be automatically deleted when the directory }
{/// container will be deleted }
{/// }
{/// the filesize passed here does*not* need to be correct, it will be used by the }
{/// filesystem generator to preallocate space so it must be the*maximum* space the final }
{/// version of the file may need (worst-case). }
{/// }
{/// Priority specifies some user-defined ordinal defining the order in which the files are }
{/// being written to the disc physically (like .ifo comes before .vob). }
{/// Priorities are valid across directories }
{/// The fileentry order in a directory is defined by the directoryPriority parameter which is the primary }
{/// sort criterium when arranging the files in a directory (Note that this is only true for }
{/// filesystems that do not require files to be sorted in the directory, e.g. UDF) }
{/// If any of the priority specifiers is -1, the producer doesn't care about the priority }
{/// and Nero will put the file where it thinks it fit }
{/// AddFile will return NULL if a file with the same name already exists }
var
  AddFile: function(const name: PChar; 
                    const fp: PIFILEPRODUCER; 
                    size: __INT64; 
                    priority: Integer; 
                    directoryPriority: var Integer): VIRTUAL IDIRECTORYENTRYCONTAINER cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 

{/// Add a file which exists in the real file system }
var
  AddFile: function(const name: PChar; 
                    const sourcePath: PChar; 
                    priority: Integer; 
                    directoryPriority: var Integer): VIRTUAL IDIRECTORYENTRYCONTAINER cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 

{/// Remove an entry from the directory }
var
  RemoveEntry: function(const name: PChar): VIRTUAL cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 

var
  Entry: function(const name: PChar): PVIRTUAL IDIRECTORYENTRYCONTAINER cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  Entry: function(i: var Integer): VIRTUAL IDIRECTORYENTRYCONTAINER cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  SubDirectory: function(const name: PChar): PVIRTUAL IDIRECTORYCONTAINER cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 


{/// Represents the content of a file system }
type
  IFileSystemDescContainer : public IFileSystemContent = record
    =0: VIRTUAL VOID SETNAME(CONST CHAR* );
    =0: VIRTUAL IDIRECTORYCONTAINER*ROOT();
{/// Called by the application when the object is not needed anymore }
    0: VIRTUAL VOID RELEASE() CONST =;
  end {IFileSystemDescContainer : public IFileSystemContent};


{$ENDIF //__NEROFILESYSTEMCONTENT_H}

var
  DLLLoaded: Boolean { is DLL (dynamically) loaded already? }
    {$IFDEF WIN32} = False; {$ENDIF}

implementation

var
  SaveExit: pointer;
  DLLHandle: THandle;
{$IFNDEF MSDOS}
  ErrorMode: Integer;
{$ENDIF}

  procedure NewExit; far;
  begin
    ExitProc := SaveExit;
    FreeLibrary(DLLHandle)
  end {NewExit};

procedure LoadDLL;
begin
  if DLLLoaded then Exit;
{$IFNDEF MSDOS}
  ErrorMode := SetErrorMode($8000{SEM_NoOpenFileErrorBox});
{$ENDIF}
  DLLHandle := LoadLibrary('NEROFILESYSTEMCONTENT.DLL');
  if DLLHandle >= 32 then
  begin
    DLLLoaded := True;
    SaveExit := ExitProc;
    ExitProc := @NewExit;
    @GetOtherInterface := GetProcAddress(DLLHandle,'GetOtherInterface');
  {$IFDEF WIN32}
    Assert(@GetOtherInterface <> nil);
  {$ENDIF}
    @GetOtherInterface := GetProcAddress(DLLHandle,'GetOtherInterface');
  {$IFDEF WIN32}
    Assert(@GetOtherInterface <> nil);
  {$ENDIF}
    @~InterfaceBase := GetProcAddress(DLLHandle,'~InterfaceBase');
  {$IFDEF WIN32}
    Assert(@~InterfaceBase <> nil);
  {$ENDIF}
    @Read := GetProcAddress(DLLHandle,'Read');
  {$IFDEF WIN32}
    Assert(@Read <> nil);
  {$ENDIF}
    @EndOfFile := GetProcAddress(DLLHandle,'EndOfFile');
  {$IFDEF WIN32}
    Assert(@EndOfFile <> nil);
  {$ENDIF}
    @Error := GetProcAddress(DLLHandle,'Error');
  {$IFDEF WIN32}
    Assert(@Error <> nil);
  {$ENDIF}
    @Release := GetProcAddress(DLLHandle,'Release');
  {$IFDEF WIN32}
    Assert(@Release <> nil);
  {$ENDIF}
    @GetName := GetProcAddress(DLLHandle,'GetName');
  {$IFDEF WIN32}
    Assert(@GetName <> nil);
  {$ENDIF}
    @GetSubDirectory := GetProcAddress(DLLHandle,'GetSubDirectory');
  {$IFDEF WIN32}
    Assert(@GetSubDirectory <> nil);
  {$ENDIF}
    @GetContent := GetProcAddress(DLLHandle,'GetContent');
  {$IFDEF WIN32}
    Assert(@GetContent <> nil);
  {$ENDIF}
    @GetSourceFilePath := GetProcAddress(DLLHandle,'GetSourceFilePath');
  {$IFDEF WIN32}
    Assert(@GetSourceFilePath <> nil);
  {$ENDIF}
    @GetSize := GetProcAddress(DLLHandle,'GetSize');
  {$IFDEF WIN32}
    Assert(@GetSize <> nil);
  {$ENDIF}
    @GetFilePriority := GetProcAddress(DLLHandle,'GetFilePriority');
  {$IFDEF WIN32}
    Assert(@GetFilePriority <> nil);
  {$ENDIF}
    @GetDirOrder := GetProcAddress(DLLHandle,'GetDirOrder');
  {$IFDEF WIN32}
    Assert(@GetDirOrder <> nil);
  {$ENDIF}
    @GetId := GetProcAddress(DLLHandle,'GetId');
  {$IFDEF WIN32}
    Assert(@GetId <> nil);
  {$ENDIF}
    @GetDataStartSec := GetProcAddress(DLLHandle,'GetDataStartSec');
  {$IFDEF WIN32}
    Assert(@GetDataStartSec <> nil);
  {$ENDIF}
    @GetNumEntries := GetProcAddress(DLLHandle,'GetNumEntries');
  {$IFDEF WIN32}
    Assert(@GetNumEntries <> nil);
  {$ENDIF}
    @GetDirectoryEntry := GetProcAddress(DLLHandle,'GetDirectoryEntry');
  {$IFDEF WIN32}
    Assert(@GetDirectoryEntry <> nil);
  {$ENDIF}
    @GetName := GetProcAddress(DLLHandle,'GetName');
  {$IFDEF WIN32}
    Assert(@GetName <> nil);
  {$ENDIF}
    @GetRoot := GetProcAddress(DLLHandle,'GetRoot');
  {$IFDEF WIN32}
    Assert(@GetRoot <> nil);
  {$ENDIF}
    @Write := GetProcAddress(DLLHandle,'Write');
  {$IFDEF WIN32}
    Assert(@Write <> nil);
  {$ENDIF}
    @ProduceFile := GetProcAddress(DLLHandle,'ProduceFile');
  {$IFDEF WIN32}
    Assert(@ProduceFile <> nil);
  {$ENDIF}
    @Release := GetProcAddress(DLLHandle,'Release');
  {$IFDEF WIN32}
    Assert(@Release <> nil);
  {$ENDIF}
    @SetSize := GetProcAddress(DLLHandle,'SetSize');
  {$IFDEF WIN32}
    Assert(@SetSize <> nil);
  {$ENDIF}
    @SetPriority := GetProcAddress(DLLHandle,'SetPriority');
  {$IFDEF WIN32}
    Assert(@SetPriority <> nil);
  {$ENDIF}
    @SetDirOrder := GetProcAddress(DLLHandle,'SetDirOrder');
  {$IFDEF WIN32}
    Assert(@SetDirOrder <> nil);
  {$ENDIF}
    @SetDataStartSec := GetProcAddress(DLLHandle,'SetDataStartSec');
  {$IFDEF WIN32}
    Assert(@SetDataStartSec <> nil);
  {$ENDIF}
    @SetFixedDataStartSec := GetProcAddress(DLLHandle,'SetFixedDataStartSec');
  {$IFDEF WIN32}
    Assert(@SetFixedDataStartSec <> nil);
  {$ENDIF}
    @SetFileNumber := GetProcAddress(DLLHandle,'SetFileNumber');
  {$IFDEF WIN32}
    Assert(@SetFileNumber <> nil);
  {$ENDIF}
    @SetId := GetProcAddress(DLLHandle,'SetId');
  {$IFDEF WIN32}
    Assert(@SetId <> nil);
  {$ENDIF}
    @SetFlags := GetProcAddress(DLLHandle,'SetFlags');
  {$IFDEF WIN32}
    Assert(@SetFlags <> nil);
  {$ENDIF}
    @GetFileProducer := GetProcAddress(DLLHandle,'GetFileProducer');
  {$IFDEF WIN32}
    Assert(@GetFileProducer <> nil);
  {$ENDIF}
    @MeasureSize := GetProcAddress(DLLHandle,'MeasureSize');
  {$IFDEF WIN32}
    Assert(@MeasureSize <> nil);
  {$ENDIF}
    @SetDirRecordSize := GetProcAddress(DLLHandle,'SetDirRecordSize');
  {$IFDEF WIN32}
    Assert(@SetDirRecordSize <> nil);
  {$ENDIF}
    @AddDirectory := GetProcAddress(DLLHandle,'AddDirectory');
  {$IFDEF WIN32}
    Assert(@AddDirectory <> nil);
  {$ENDIF}
    @AddFile := GetProcAddress(DLLHandle,'AddFile');
  {$IFDEF WIN32}
    Assert(@AddFile <> nil);
  {$ENDIF}
    @AddFile := GetProcAddress(DLLHandle,'AddFile');
  {$IFDEF WIN32}
    Assert(@AddFile <> nil);
  {$ENDIF}
    @RemoveEntry := GetProcAddress(DLLHandle,'RemoveEntry');
  {$IFDEF WIN32}
    Assert(@RemoveEntry <> nil);
  {$ENDIF}
    @Entry := GetProcAddress(DLLHandle,'Entry');
  {$IFDEF WIN32}
    Assert(@Entry <> nil);
  {$ENDIF}
    @Entry := GetProcAddress(DLLHandle,'Entry');
  {$IFDEF WIN32}
    Assert(@Entry <> nil);
  {$ENDIF}
    @SubDirectory := GetProcAddress(DLLHandle,'SubDirectory');
  {$IFDEF WIN32}
    Assert(@SubDirectory <> nil);
  {$ENDIF}
  end
  else
  begin
    DLLLoaded := False;
    { Error: NEROFILESYSTEMCONTENT.DLL could not be loaded !! }
  end;
{$IFNDEF MSDOS}
  SetErrorMode(ErrorMode)
{$ENDIF}
end {LoadDLL};

begin
  LoadDLL;
end.
