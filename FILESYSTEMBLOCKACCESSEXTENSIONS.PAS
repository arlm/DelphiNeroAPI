unit FILESYSTEMBLOCKACCESSEXTENSIONS;
{**************************************************************************}
{                                                                          }
{    This C DLL header file first (automatic) conversion generated by:     }
{    HeadConv 4.0 (c) 2000 by Bob Swart (aka Dr.Bob - www.drbob42.com)     }
{      Final Delphi-Jedi (Darth) command-line units edition                }
{                                                                          }
{    Generated Date: 02/06/2003                                            }
{    Generated Time: 11:11:18                                              }
{                                                                          }
{**************************************************************************}

interface
uses
{$IFDEF WIN32}
  Windows;
{$ELSE}
  Wintypes, WinProcs;
{$ENDIF}


{=> NeroFileSystemManager\FILESYSTEMBLOCKACCESSEXTENSIONS.H <=}

{+//***************************************************************************** }
{-|* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF }
{-|* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO }
{-|* THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A }
{-|* PARTICULAR PURPOSE. }
{-|* }
{-|* Copyright 1995-2003 Ahead Software AG. All Rights Reserved. }
{-|*----------------------------------------------------------------------------- }
{-|* NeroSDK / NeroAPI }
{-|* }
{-|* PROGRAM: FileSystemBlockAccessExtensions.h }
{-|* }
{-|* PURPOSE: All block device access extensions are derived from this one. }
{-|* }
{=***************************************************************************** }
{$IFNDEF FILESYSTEMBLOCKACCESSEXTENSIONS_H}
{$DEFINE FILESYSTEMBLOCKACCESSEXTENSIONS_H}

{+// }
{-* Type of an extension. }
{-* Currently no extension is provided within the NeroSDK }
{= }
type
  NeroFSBlockAccessExtensionsType = (
    etMRWReadDefectiveManagementInfo, 
    etDVDPRWFormatExtension, 
    etSectorMappingControlExtension, 
    etBlankAreaControlExtension, 
    etIllegalBlockAccessExtension  );

var
  GetExtensionType: function: PUBLIC: VIRTUAL NEROFSBLOCKACCESSEXTENSIONSTYPE cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 

var
  ~INeroFileSystemBlockAccessExtension: function: VIRTUAL cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 

{$ENDIF // FILESYSTEMBLOCKACCESSEXTENSIONS_H}

var
  DLLLoaded: Boolean { is DLL (dynamically) loaded already? }
    {$IFDEF WIN32} = False; {$ENDIF}

implementation

var
  SaveExit: pointer;
  DLLHandle: THandle;
{$IFNDEF MSDOS}
  ErrorMode: Integer;
{$ENDIF}

  procedure NewExit; far;
  begin
    ExitProc := SaveExit;
    FreeLibrary(DLLHandle)
  end {NewExit};

procedure LoadDLL;
begin
  if DLLLoaded then Exit;
{$IFNDEF MSDOS}
  ErrorMode := SetErrorMode($8000{SEM_NoOpenFileErrorBox});
{$ENDIF}
  DLLHandle := LoadLibrary('FILESYSTEMBLOCKACCESSEXTENSIONS.DLL');
  if DLLHandle >= 32 then
  begin
    DLLLoaded := True;
    SaveExit := ExitProc;
    ExitProc := @NewExit;
    @GetExtensionType := GetProcAddress(DLLHandle,'GetExtensionType');
  {$IFDEF WIN32}
    Assert(@GetExtensionType <> nil);
  {$ENDIF}
    @~INeroFileSystemBlockAccessExtension := GetProcAddress(DLLHandle,'~INeroFileSystemBlockAccessExtension');
  {$IFDEF WIN32}
    Assert(@~INeroFileSystemBlockAccessExtension <> nil);
  {$ENDIF}
  end
  else
  begin
    DLLLoaded := False;
    { Error: FILESYSTEMBLOCKACCESSEXTENSIONS.DLL could not be loaded !! }
  end;
{$IFNDEF MSDOS}
  SetErrorMode(ErrorMode)
{$ENDIF}
end {LoadDLL};

begin
  LoadDLL;
end.
