unit NEROUSERDIALOG;
{**************************************************************************}
{                                                                          }
{    This C DLL header file first (automatic) conversion generated by:     }
{    HeadConv 4.0 (c) 2000 by Bob Swart (aka Dr.Bob - www.drbob42.com)     }
{      Final Delphi-Jedi (Darth) command-line units edition                }
{                                                                          }
{    Generated Date: 02/06/2003                                            }
{    Generated Time: 11:51:56                                              }
{                                                                          }
{**************************************************************************}

interface
uses
{$IFDEF WIN32}
  Windows;
{$ELSE}
  Wintypes, WinProcs;
{$ENDIF}


{=> D:\Projects\delphi\headconv\Source\NeroSDK-v1.02\NeroAPI\Include\NEROUSERDIALOG.H <=}

{+//***************************************************************************** }
{-|* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF }
{-|* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO }
{-|* THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A }
{-|* PARTICULAR PURPOSE. }
{-|* }
{-|* Copyright 1995-2003 Ahead Software AG. All Rights Reserved. }
{-|*----------------------------------------------------------------------------- }
{-|* NeroSDK / NeroAPI }
{-|* }
{-|* PROGRAM: NeroUserDialog.h }
{-|* }
{-|* PURPOSE: Ask how to proceed by offering the user some choices }
{=***************************************************************************** }


{$IFNDEF __NEROUSERDIALOG__}
{$DEFINE __NEROUSERDIALOG__}

{/// Take care to use 2^n as values for constants: }
const
  AUP_NO_PROBLEM = 0; {// No problems found}
const
  AUP_FIRST_TR_PAUSE = 1; {// First track must have 2-3 secs pause!}
const
  AUP_PAUSE_SETTINGS = 2; {// Problem with audio pause settings (tracks > 1)}
const
  AUP_INDEX_SETTINGS = 4; {// Problem with audio index settings}
const
  AUP_ISRC_SETTINGS = 8; {// Problem with ISRC settings}
const
  AUP_COPYPROT_SETTINGS = 16; {// Problem with copyright settings}
const
  AUP_NOTRACK_FOUND = 32; {// Problem because we don´t have any track}
const
  AUP_MEGA_FATAL = $FFFFFFF; {// Megafatal internal problem that can´t be fixed!}

type
  NeroUserDlgInOutEnum = (
    DLG_RETURN_EXIT {= 0}, 
    DLG_RETURN_FALSE {= 0}, 
    DLG_RETURN_TRUE {= 1}, 
    DLG_DISCONNECT, 
    DLG_RETURN_ON_RESTART, 
    DLG_RETURN_RESTART, 
    DLG_RETURN_CONTINUE, 
    LG_DISCONNECT_RESTART, 
    DLG_AUTO_INSERT, 
    DLG_RETURN_INSTALL_DRIVER, 
    DLG_RETURN_OFF_RESTART, 
    DLG_RESTART, 
    DLG_AU, 
    NeroUserDlgInOut;, 
    typedef enum {, 
    RUMT_ERROR, 
    RUMT_WARNING, 
    RUMT_QUESTION, 
    RUMT_HINT  );

type
  ROBOUSERMESSAGE = record
    message_type: ROBOUSERMESSAGETYPE;
    message: PCONST CHAR;
  end {ROBOUSERMESSAGE};

type
  ROBOMOVEMESSAGE = (
    RMN_INPUT, 
    RMN_RECORDER, 
    RMN_OUTPUT, 
    RMN_PRINTER, 
    RMN_WASTEBIN  );

type
  ROBOMOVEMESSAGE = record
    id: Integer;
{- In future versions, we may have more than one Robo moving }
{-* at a time. So this ID identifies the movement action }
{=* and will be used to remove it with DLG_ROBO_MOVECD_DONE }
    source: ROBOMOVENODE;
    destination: ROBOMOVENODE;
  end {ROBOMOVEMESSAGE};


{+// }
{/// This function gets a requester type and shall return a suitable response to it. }
{/// Depending on the "type", "data" might contain additional information. }
{/// }
{/// Argument passing is in standard C order (on the stack, right to left), }
{/// aka MS Visual++ __cdecl. }
{= }

{+// Define __cdecl for non-Microsoft compilers*/ }

{$IFDEF ( !defined(_MSC_VER) && !defined(__cdecl) )}
{$DEFINE __cdecl}
{$ENDIF}

const
  NERO_CALLBACK_ATTR = __cdecl;
type
  = NEROUSERDLGINOUT (NERO_CALLBACK_ATTR*NERO_USER_DIALOG) (VOID*PUSERDATA, NEROUSERDLGINOUT TYPE, VOID*DATA);

{+// }
{/// see below for a description of the enumeration values }
{= }
type
  static = (
    NERO_WAITCD_WRITE, 
    NERO_WAITCD_SIMULATION, 
    NERO_WAITCD_AUTOEJECTLOAD, 
    NERO_WAITCD_REINSERT, 
    NERO_WAITCD_NEXTCD, 
    NERO_WAITCD_ORIGINAL, 
    NERO_WAITCD_WRITEPROTECTED, 
    NERO_WAITCD_NOTENOUGHSPACE, 
    NERO_WAITCD_NEWORIGINAL, 
    NERO_WAITCD_EMPTYCD, 
    NERO_WAITCD_WRITE_, 
    NERO_WAITCD_TYPE;, 
    {$ENDIF /* __NEROUSERDIALOG__*/ );



{$IFDEF NERO_WAITCD_TEXTS /* define this in exactly one source file before including NeroUserDialog.h there.*/}

{$INCLUDE <assert.h>}

{$IFNDEF NERO_WAITCD_TEXTS_DEFINED}
{$DEFINE NERO_WAITCD_TEXTS_DEFINED}


{+// If NeroAPI>=5.5.9.10 is present, it is recommanded to use NeroGetLocalizedWaitCDTexts instead since it }
{=returns a localized string }
var
  NeroGetWaitCDTexts: function(type: NERO_WAITCD_TYPE): PCONST CHAR cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
type
  static = record
    type: NERO_WAITCD_TYPE;
    text: PCONST CHAR;
  end {static};
{
var
  simulation...\n\n: function(}: NOTHING WILL BE WRITTEN ON THE CD.)"; 
                              )

                              )

                              _4: NERO_WAITCD_AUTOEJECTLOAD; 
                              }: "PLEASE DO NOT REMOVE THE CD!\N\NYOUR RECORDER REQUIRES THIS EJECT BETWEEN SIMULATION AND BURNING. THE CD WILL BE RELOADED AUTOMATICALLY BEFORE CONTINUING WITH BURNING..."; 
                              )

                              )

                              _8: NERO_WAITCD_REINSERT; 
                              }: "PLEASE DO NOT REMOVE THE CD!\N\NYOUR RECORDER REQUIRES THIS EJECT BETWEEN SIMULATION AND BURNING. PLEASE REINSERT THE CD..."; 
                              )

                              )

                              _12: NERO_WAITCD_NEXTCD; 
                              }: "PLEASE REMOVE THE CD AND INSERT THE NEXT CD-RECORDABLE TO WRITE TO... "; 
                              )

                              )

                              _16: NERO_WAITCD_ORIGINAL; 
                              }: "PLEASE INSERT THE ORIGINAL CD."; 
                              )

                              )

                              _20: NERO_WAITCD_WRITEPROTECTED; 
                              }: "THIS CD IS NOT WRITABLE.\N\NPLEASE INSERT A WRITABLE CD..."; 
                              )

                              )

                              _24: NERO_WAITCD_NOTENOUGHSPACE; 
                              }: "THERE IS NOT ENOUGH SPACE TO BURN THIS COMPILATION ONTO THIS CD.\N\NPLEASE INSERT ANOTHER CD THAT PROVIDES MORE SPACE..."; 
                              )

                              )

                              _28: NERO_WAITCD_NEWORIGINAL; 
                              blank: "THE CD IS; 
                              }: INVALID\NOR A MULTISESSION CD.\N\NPLEASE INSERT ORIGINAL CD ..."; 
                              )

                              )

                              _33: NERO_WAITCD_EMPTYCD; 
                              }: "THE CD IS NOT EMPTY.\N\NPLEASE INSERT AN EMPTY CD."; 
                              )

                              )

                              _37: NERO_WAITCD_WRITE_EMPTY; 
                              }: "PLEASE INSERT AN EMPTY CD TO WRITE TO..."; 
                              )

                              )

                              _41: NERO_WAITCD_SIMULATION_EMPTY; 
                              }: "PLEASE INSERT AN EMPTY CD TO USE DURING SIMULATION...\N\N(NOTHING WILL BE WRITTEN ON THE CD.)"; 
                              )

                              )

                              _45: NERO_WAITCD_WRITEWAVE; 
                              }: "THE CD IS BLANK.\N\NPLEASE INSERT ORIGINAL CD..."; 
                              )

                              )

                              _49: NERO_WAITCD_MULTISESSION; 
                              CD: "NERO IS CHECKING FOR THE; 
                              var CD: LEASE WAIT ...\N\NTO BURN THIS MULTISESSION COMPILATION YOU NEED THE; 
                              }: THAT CONTAINS THE PREVIOUS BACKUP SESSIONS. PLEASE INSERT THIS CD IF YOU HAVEN'T DONE IT BEFORE."; 
                              )

                              )

                              _55: NERO_WAITCD_MULTISESSION_SIM; 
                              CD: "TO SIMULATE THIS MULTISESSION COMPILATION YOU NEED THE; 
                              }: THAT CONTAINS THE PREVIOUS BACKUP SESSIONS. PLEASE INSERT THIS CD. (NOTHING WILL BE WRITTEN ON CD)."; 
                              )

                              )

                              _60: NERO_WAITCD_MULTI_REINSERT; 
                              }: "PLEASE DO NOT REMOVE THE CD!\N\NYOUR RECORDER REQUIRES THIS EJECT BETWEEN SIMULATION AND BURNING. PLEASE REINSERT THE\N SAME MULTISESSION CD..."; 
                              )

                              )

                              reason."}: NERO_WAITCD_DISCINFOS_FAILED, "DISC ANALYSIS FAILED. THE ERROR LOG\NCONTAINS MORE INFORMATION ABOUT THE): NERO_WAITCD_SIMULATION "PLEASE INSERT A CD TO USE cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 

var
  for: function(0;: I =; 
                var NERO_WAITCD_MAX;: MAPPING[I].TYPE != TYPE & MAPPING[I].TYPE !=; 
                _3: I++): Integer cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  assert: function(NERO_WAITCD_MAX: MAPPING[I].TYPE !=): Integer cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
{$ENDIF}

{$ENDIF}

var
  DLLLoaded: Boolean { is DLL (dynamically) loaded already? }
    {$IFDEF WIN32} = False; {$ENDIF}

implementation

var
  SaveExit: pointer;
  DLLHandle: THandle;
{$IFNDEF MSDOS}
  ErrorMode: Integer;
{$ENDIF}

  procedure NewExit; far;
  begin
    ExitProc := SaveExit;
    FreeLibrary(DLLHandle)
  end {NewExit};

procedure LoadDLL;
begin
  if DLLLoaded then Exit;
{$IFNDEF MSDOS}
  ErrorMode := SetErrorMode($8000{SEM_NoOpenFileErrorBox});
{$ENDIF}
  DLLHandle := LoadLibrary('NEROUSERDIALOG.DLL');
  if DLLHandle >= 32 then
  begin
    DLLLoaded := True;
    SaveExit := ExitProc;
    ExitProc := @NewExit;
    @NeroGetWaitCDTexts := GetProcAddress(DLLHandle,'NeroGetWaitCDTexts');
  {$IFDEF WIN32}
    Assert(@NeroGetWaitCDTexts <> nil);
  {$ENDIF}
    @simulation...\n\n := GetProcAddress(DLLHandle,'simulation...\n\n');
  {$IFDEF WIN32}
    Assert(@simulation...\n\n <> nil);
  {$ENDIF}
    @for := GetProcAddress(DLLHandle,'for');
  {$IFDEF WIN32}
    Assert(@for <> nil);
  {$ENDIF}
    @assert := GetProcAddress(DLLHandle,'assert');
  {$IFDEF WIN32}
    Assert(@assert <> nil);
  {$ENDIF}
  end
  else
  begin
    DLLLoaded := False;
    { Error: NEROUSERDIALOG.DLL could not be loaded !! }
  end;
{$IFNDEF MSDOS}
  SetErrorMode(ErrorMode)
{$ENDIF}
end {LoadDLL};

begin
  LoadDLL;
end.
