unit NEROUSERDIALOG;
{**************************************************************************}
{                                                                          }
{    This C DLL header file first (automatic) conversion generated by:     }
{    HeadConv 4.0 (c) 2000 by Bob Swart (aka Dr.Bob - www.drbob42.com)     }
{      Final Delphi-Jedi (Darth) command-line units edition                }
{                                                                          }
{    Generated Date: 02/06/2003                                            }
{    Generated Time: 11:51:56                                              }
{                                                                          }
{**************************************************************************}

interface
uses
{$IFDEF WIN32}
  Windows;
{$ELSE}
  Wintypes, WinProcs;
{$ENDIF}


{$IFNDEF __NEROUSERDIALOG__}
{$DEFINE __NEROUSERDIALOG__}

{/// Take care to use 2^n as values for constants: }
const
  AUP_NO_PROBLEM = 0; {// No problems found}
  AUP_FIRST_TR_PAUSE = 1; {// First track must have 2-3 secs pause!}
  AUP_PAUSE_SETTINGS = 2; {// Problem with audio pause settings (tracks > 1)}
  AUP_INDEX_SETTINGS = 4; {// Problem with audio index settings}
  AUP_ISRC_SETTINGS = 8; {// Problem with ISRC settings}
  AUP_COPYPROT_SETTINGS = 16; {// Problem with copyright settings}
  AUP_NOTRACK_FOUND = 32; {// Problem because we don´t have any track}
  AUP_MEGA_FATAL = $FFFFFFF; {// Megafatal internal problem that can´t be fixed!}

type
  NeroUserDlgInOutEnum = (
    DLG_RETURN_EXIT {= 0},
    DLG_RETURN_FALSE {= 0},
    DLG_RETURN_TRUE {= 1},
    DLG_DISCONNECT,
    DLG_RETURN_ON_RESTART,
    DLG_RETURN_RESTART,
    DLG_RETURN_CONTINUE,
    DLG_DISCONNECT_RESTART,
    DLG_AUTO_INSERT,
    DLG_RETURN_INSTALL_DRIVER,
    DLG_RETURN_OFF_RESTART,
    DLG_RESTART,
    DLG_AUTO_INSERT_RESTART,
    DLG_SETTINGS_RESTART,
    DLG_OVERBURN,
    DLG_AUDIO_PROBLEMS,
    DLG_WAITCD,
    DLG_WAITCD_REMINDER,
    DLG_WAITCD_DONE,
    DLG_COPY_QUALITY_LOSS,
    DLG_COPY_FULLRISK,
    DLG_FILESEL_IMAGE,
    DLG_BURNIMAGE_CANCEL,
    DLG_NON_EMPTY_CDRW,
    DLG_COMP_REC_CONFLICT,
    DLG_WRONG_MEDIUM,
    DLG_ROBO_MOVECD,
    DLG_ROBO_MOVECD_DONE,
    DLG_ROBO_USERMESSAGE,
    DLG_WAITCD_MEDIA_INFO,
    DLG_MAX);
    NeroUserDlgInOut= NeroUserDlgInOutEnum;

    ROBOUSERMESSAGETYPE = (
    RUMT_ERROR,
    RUMT_WARNING,
    RUMT_QUESTION,
    RUMT_HINT);

  ROBOUSERMESSAGE = record
    message_type: ROBOUSERMESSAGETYPE;
    message: PCHAR;
  end;

  ROBOMOVENODE = (
    RMN_INPUT,
    RMN_RECORDER,
    RMN_OUTPUT,
    RMN_PRINTER,
    RMN_WASTEBIN);

  ROBOMOVEMESSAGE = record
    id: Integer;
    source: ROBOMOVENODE;
    destination: ROBOMOVENODE;
  end;

{$DEFINE __cdecl}

 NERO_USER_DIALOG =  function (PUSERDATA: Pointer; dlgTYPE: NEROUSERDLGINOUTEnum; DATA: Pointer): NeroUserDlgInOut; cdecl;
 PNeroUserDialog = ^NERO_USER_DIALOG;

  NERO_WAITCD_TYPE = (
    NERO_WAITCD_WRITE,
    NERO_WAITCD_SIMULATION,
    NERO_WAITCD_AUTOEJECTLOAD,
    NERO_WAITCD_REINSERT,
    NERO_WAITCD_NEXTCD,
    NERO_WAITCD_ORIGINAL,
    NERO_WAITCD_WRITEPROTECTED,
    NERO_WAITCD_NOTENOUGHSPACE,
    NERO_WAITCD_NEWORIGINAL,
    NERO_WAITCD_EMPTYCD,
    NERO_WAITCD_WRITE_EMPTY,
    NERO_WAITCD_SIMULATION_EMPTY,
    NERO_WAITCD_WRITEWAVE,
    NERO_WAITCD_MULTISESSION,
    NERO_WAITCD_MULTISESSION_SIM,
    NERO_WAITCD_MULTI_REINSERT,
	NERO_WAITCD_DISCINFOS_FAILED,
	NERO_WAITCD_MEDIUM_UNSUPPORTED,
	NERO_WAITCD_AUTOEJECTLOAD_VER,
	NERO_WAITCD_REINSERT_VER,
	NERO_WAITCD_NOFORMAT,
	NERO_WAITCD_WRONG_MEDIUM,		// NeroAPI>=5.5.5.6
	NERO_WAITCD_MAX);

{$ENDIF /* __NEROUSERDIALOG__*/ }

implementation

{$ifdef NERO_WAITCD_TEXTS}

  {$ifndef NERO_WAITCD_TEXTS_DEFINED}
    {$define NERO_WAITCD_TEXTS_DEFINED}
    function  NeroGetWaitCDTexts(dlgType: NERO_WAITCD_TYPE): PCHAR cdecl  {$IFDEF WIN32} stdcall {$ENDIF};
    type
      MappingType = record
        mapType: NERO_WAITCD_TYPE;
        text: PChar;
      end;
    var
      mapping: array [1.. 23] of MappingType;
      i: Integer;
    begin

      mapping[1].mapType := NERO_WAITCD_WRITE;
      mapping[1].text := 'Please insert the CD to write to...';
      mapping[2].mapType := NERO_WAITCD_SIMULATION;
      mapping[2].text := 'Please insert a CD to use during simulation...\n\n(Nothing will be written on the CD.)';
      mapping[3].mapType := NERO_WAITCD_AUTOEJECTLOAD;
      mapping[3].text := 'Please do not remove the CD!\n\nYour recorder requires this eject between simulation and burning. The CD will be reloaded automatically before continuing with burning...';
      mapping[4].mapType := NERO_WAITCD_REINSERT;
      mapping[4].text := 'Please do not remove the CD!\n\nYour recorder requires this eject between simulation and burning. Please reinsert the CD...';
      mapping[5].mapType := NERO_WAITCD_NEXTCD;
      mapping[5].text := 'Please remove the CD and  insert the next CD-Recordable to write to... ';
      mapping[6].mapType := NERO_WAITCD_ORIGINAL;
      mapping[6].text := 'Please insert the original CD.';
      mapping[7].mapType := NERO_WAITCD_WRITEPROTECTED;
      mapping[7].text := 'This CD is not writable.\n\nPlease insert a writable CD...';
      mapping[8].mapType := NERO_WAITCD_NOTENOUGHSPACE;
      mapping[8].text := 'There is not enough space to burn this compilation onto this CD.\n\nPlease insert another CD that provides more space...';
      mapping[9].mapType := NERO_WAITCD_NEWORIGINAL;
      mapping[9].text := 'The CD is blank, invalid\nor a multisession CD.\n\nPlease insert original CD ...';
      mapping[10].mapType := NERO_WAITCD_EMPTYCD;
      mapping[10].text := 'The CD is not empty.\n\nPlease insert an empty CD.';
      mapping[11].mapType := NERO_WAITCD_WRITE_EMPTY;
      mapping[11].text := 'Please insert an empty CD to write to...';
      mapping[12].mapType := NERO_WAITCD_SIMULATION_EMPTY;
      mapping[12].text := 'Please insert an empty CD to use during simulation...\n\n(Nothing will be written on the CD.)';
      mapping[13].mapType := NERO_WAITCD_WRITEWAVE;
      mapping[13].text := 'The CD is blank.\n\nPlease insert original CD...';
      mapping[14].mapType := NERO_WAITCD_MULTISESSION;
      mapping[14].text := 'Nero is checking for the CD, please wait ...\n\nTo burn this multisession compilation you need the CD, that  contains the previous backup sessions. Please insert this CD if you haven`t done it before.';
      mapping[15].mapType := NERO_WAITCD_MULTISESSION_SIM;
      mapping[15].text := 'To simulate this multisession compilation you need the CD, that contains the previous backup sessions. Please insert this CD. (Nothing will be written on CD).';
      mapping[16].mapType := NERO_WAITCD_MULTI_REINSERT;
      mapping[16].text := 'Please do not remove the CD!\n\nYour recorder requires this eject between simulation and burning. Please reinsert the\n same Multisession CD...';
      mapping[17].mapType := NERO_WAITCD_DISCINFOS_FAILED;
      mapping[17].text := 'Disc analysis failed. The error log\ncontains more information about the reason.';
      mapping[18].mapType := NERO_WAITCD_MEDIUM_UNSUPPORTED;
      mapping[18].text := 'The recorder does not support this type of media!\n\nPlease insert a correct CD to write to...';
      mapping[19].mapType := NERO_WAITCD_AUTOEJECTLOAD_VER;
      mapping[19].text := 'Please do not remove the CD!\n\nYour recorder requires that the  CD be ejected between burning and verification. The CD will be reloaded automatically when burning is to continue...';
      mapping[20].mapType := NERO_WAITCD_REINSERT_VER;
      mapping[20].text := 'Please do not remove the CD!\n\nYour recorder requires that the  CD be ejected between burning and verification.  Please reinsert the CD....';
      mapping[21].mapType := NERO_WAITCD_NOFORMAT;
      mapping[21].text := 'Medium is not formatted. Please insert a formatted medium.';
      mapping[22].mapType := NERO_WAITCD_WRONG_MEDIUM;
      mapping[22].text := 'Sorry, your compilation cannot be written on this kind of medium. Please insert a medium of the correct type or modify the settings of your compilation to make them compatible with the current medium.';
      mapping[23].mapType := NERO_WAITCD_MAX;
      mapping[23].text := 'unknown NERO_WAITCD_TYPE';

      i := 0;
      repeat
        i := i + 1;
      until ((mapping[i].mapType <> dlgtype) and (mapping[i].mapType <> NERO_WAITCD_MAX));
        ;
      assert(mapping[i].mapType <> NERO_WAITCD_MAX);
      Result :=  mapping[i].text;
    end;
  {$ENDIF}
{$ENDIF}
end.
