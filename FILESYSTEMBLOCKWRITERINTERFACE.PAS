unit FILESYSTEMBLOCKWRITERINTERFACE;
{**************************************************************************}
{                                                                          }
{    This C DLL header file first (automatic) conversion generated by:     }
{    HeadConv 4.0 (c) 2000 by Bob Swart (aka Dr.Bob - www.drbob42.com)     }
{      Final Delphi-Jedi (Darth) command-line units edition                }
{                                                                          }
{    Generated Date: 02/06/2003                                            }
{    Generated Time: 11:12:11                                              }
{                                                                          }
{**************************************************************************}

interface
uses
{$IFDEF WIN32}
  Windows;
{$ELSE}
  Wintypes, WinProcs;
{$ENDIF}


{=> NeroFileSystemManager\FILESYSTEMBLOCKWRITERINTERFACE.H <=}

{+//***************************************************************************** }
{-|* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF }
{-|* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO }
{-|* THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A }
{-|* PARTICULAR PURPOSE. }
{-|* }
{-|* Copyright 1995-2003 Ahead Software AG. All Rights Reserved. }
{-|*----------------------------------------------------------------------------- }
{-|* NeroSDK / NeroAPI }
{-|* }
{-|* PROGRAM: FileSystemBlockWriterInterface.h }
{-|* }
{-|* PURPOSE: The FileSystem block writer interface is derived from the block }
{-|* reader interface. It defines a path of access to RW filesystems }
{-|* and partitions. }
{=***************************************************************************** }
{$IFNDEF FILESYSTEMBLOCKWRITERINTERFACE_H}
{$DEFINE FILESYSTEMBLOCKWRITERINTERFACE_H}

{$INCLUDE "FileSystemBlockReaderInterface.h"}

{/// Specifies the block writer type. }
{/// You can use this information to down-cast the interface to obtain specialized functionality... }

{/// No extensions to the normal blockwrite interface are available so far... }
type
  InterfaceType = (
    eBWIUnknown  );

{/// access. While WriteSectorsUnBuffered will merely ensure the consistency of the read cache (write thru), }
{/// WriteSectorsBuffered will not write anything to the block device immediately but will cache }
{/// a certain amount of sectors before doing so. }
{/// The latter increases performance considerably but is prone to data loss in an unstable environment. }
{/// Please note that regardless of which method you use, you*must* call FlushSectorCache() if you want }
{/// all your data to be at their final physical location because even when writing in UnBuffered mode, }
{/// the driver may decide to not write away your data immediately, depending on the underlying }
{/// writing scheme (e.g. packet writing will always try to collect a certain amount of sectors) }
var
  WriteSectorsBuffered: function(const pData: Pointer; 
                                 startSector: NEROFSSECNO; 
                                 noSectors: NEROFSSECNO; 
                                 var noSectorsWritten: NEROFSSECNO): VIRTUAL cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  WriteSectorsUnBuffered: function(const pData: Pointer; 
                                   startSector: NEROFSSECNO; 
                                   noSectors: NEROFSSECNO; 
                                   var noSectorsWritten: NEROFSSECNO): VIRTUAL cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
{/// FlushSectorCache will be performed implicitly upon deleting the block writer object }
var
  FlushSectorCache: function cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 

{/// Runtime type information to be used for downcasting into specialized interfaces... }
var
  GetBlockWriterType: function: VIRTUAL cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 


{$ENDIF // FILESYSTEMBLOCKWRITERINTERFACE_H}

var
  DLLLoaded: Boolean { is DLL (dynamically) loaded already? }
    {$IFDEF WIN32} = False; {$ENDIF}

implementation

var
  SaveExit: pointer;
  DLLHandle: THandle;
{$IFNDEF MSDOS}
  ErrorMode: Integer;
{$ENDIF}

  procedure NewExit; far;
  begin
    ExitProc := SaveExit;
    FreeLibrary(DLLHandle)
  end {NewExit};

procedure LoadDLL;
begin
  if DLLLoaded then Exit;
{$IFNDEF MSDOS}
  ErrorMode := SetErrorMode($8000{SEM_NoOpenFileErrorBox});
{$ENDIF}
  DLLHandle := LoadLibrary('FILESYSTEMBLOCKWRITERINTERFACE.DLL');
  if DLLHandle >= 32 then
  begin
    DLLLoaded := True;
    SaveExit := ExitProc;
    ExitProc := @NewExit;
    @WriteSectorsBuffered := GetProcAddress(DLLHandle,'WriteSectorsBuffered');
  {$IFDEF WIN32}
    Assert(@WriteSectorsBuffered <> nil);
  {$ENDIF}
    @WriteSectorsUnBuffered := GetProcAddress(DLLHandle,'WriteSectorsUnBuffered');
  {$IFDEF WIN32}
    Assert(@WriteSectorsUnBuffered <> nil);
  {$ENDIF}
    @FlushSectorCache := GetProcAddress(DLLHandle,'FlushSectorCache');
  {$IFDEF WIN32}
    Assert(@FlushSectorCache <> nil);
  {$ENDIF}
    @GetBlockWriterType := GetProcAddress(DLLHandle,'GetBlockWriterType');
  {$IFDEF WIN32}
    Assert(@GetBlockWriterType <> nil);
  {$ENDIF}
  end
  else
  begin
    DLLLoaded := False;
    { Error: FILESYSTEMBLOCKWRITERINTERFACE.DLL could not be loaded !! }
  end;
{$IFNDEF MSDOS}
  SetErrorMode(ErrorMode)
{$ENDIF}
end {LoadDLL};

begin
  LoadDLL;
end.
