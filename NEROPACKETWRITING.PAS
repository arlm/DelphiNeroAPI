unit NEROPACKETWRITING;
{**************************************************************************}
{                                                                          }
{    This C DLL header file first (automatic) conversion generated by:     }
{    HeadConv 4.0 (c) 2000 by Bob Swart (aka Dr.Bob - www.drbob42.com)     }
{      Final Delphi-Jedi (Darth) command-line units edition                }
{                                                                          }
{    Generated Date: 02/06/2003                                            }
{    Generated Time: 11:10:52                                              }
{                                                                          }
{**************************************************************************}

interface
uses
{$IFDEF WIN32}
  Windows;
{$ELSE}
  Wintypes, WinProcs;
{$ENDIF}


{=> NEROPACKETWRITING.H <=}

{+//***************************************************************************** }
{-|* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF }
{-|* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO }
{-|* THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A }
{-|* PARTICULAR PURPOSE. }
{-|* }
{-|* Copyright 1995-2003 Ahead Software AG. All Rights Reserved. }
{-|*----------------------------------------------------------------------------- }
{-|* NeroSDK / NeroAPI }
{-|* }
{-|* PROGRAM: NeroPacketWriting.h }
{-|* }
{-|* PURPOSE: This file defines a lowlevel packetwriting/MRW API for NeroAPI }
{=***************************************************************************** }
{$IFNDEF NEROPACKETWRITING_H}
{$DEFINE NEROPACKETWRITING_H}

{$INCLUDE "NeroAPI.h"}

{$IFDEF __cplusplus}
{$ELSE}
type
  INeroFileSystemBlockAccess = VOID;
type
  INeroFileSystemBlockReader = VOID;
{$ENDIF}


type
  NewExit = (
    eNoWriting {=0x0000}, 
    {{= Use this to instantiate an INeroFileSystemBlockAccess object for read-only access } );
var
  mode: function(}: DEFECTIVE MANAGEMENT TURNED OFF); 
                 }: EILLEGALACCESSMODE =0XFFFFFFFF; 
                 _3: ACCESSMODE;; 
                 )
: ERAWMRW =0X0004 {= USE THIS FOR RAW cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
{+// }
{/// Use the following two functions to obtain a block reader/writer to a specified NeroAPI device. }
{/// Please note that ownership of the aDeviceHandle is*not* transferred to the block writer/reader so you're }
{/// still responsible to dispose of the device handle after disposing of the writer/reader interface. }
{/// }
{/// Please note that only one object created by either NeroCreateBlockWriterInterface or }
{/// NeroCreateBlockReaderInterface may exist at a time. Also make sure to delete the object before using }
{/// the referred drive for another purpose (e.g. importing multisession data, starting a recording- or }
{/// digital audio extraction process). }
{/// Opening a secondary device handle for the drive is*not* sufficient! }
{= }
var
  NeroCreateBlockWriterInterface: function(aDeviceHandle: NERO_DEVICEHANDLE; 
                                           eAccessMode: var ACCESSMODE): NEROAPI_API INEROFILESYSTEMBLOCKACCESS cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  NeroCreateBlockReaderInterface: function(aDeviceHandle: NERO_DEVICEHANDLE; 
                                           eAccessMode: var ACCESSMODE): NEROAPI_API INEROFILESYSTEMBLOCKREADER cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 

type
  NewExit = (
    eIAReadOnly {= 0x0000}, 
    eIAReadWrite {= 0x0001}, 
    eIAIllegalAccessMode {= 0xffffffff } );

{+// }
{/// Create a block access interface for the specified image file }
{/// Instead of an image file, you may pass a drive letter }
{/// here to read from a specific device supported by the operating system }
{= }
var
  NeroCreateBlockAccessFromImage: function(const szFilename: PChar; 
                                           eAccessMode: var IMAGEACCESSMODE): NEROAPI_API INEROFILESYSTEMBLOCKACCESS cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 

{+// }
{/// This function will return a DWORD mask containing values as declared in enum AccessMode. }
{/// Use ((result&eDesiredMode)!=0) to determine whether a specific mode is supported. }
{= }
var
  NeroGetSupportedAccessModesForDevice: function(aDeviceHandle: NERO_DEVICEHANDLE): NEROAPI_API DWORD cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 

{$IFDEF __cplusplus}
{$ENDIF}


{$ENDIF // NEROPACKETWRITING_H}

var
  DLLLoaded: Boolean { is DLL (dynamically) loaded already? }
    {$IFDEF WIN32} = False; {$ENDIF}

implementation

var
  SaveExit: pointer;
  DLLHandle: THandle;
{$IFNDEF MSDOS}
  ErrorMode: Integer;
{$ENDIF}

  procedure NewExit; far;
  begin
    ExitProc := SaveExit;
    FreeLibrary(DLLHandle)
  end {NewExit};

procedure LoadDLL;
begin
  if DLLLoaded then Exit;
{$IFNDEF MSDOS}
  ErrorMode := SetErrorMode($8000{SEM_NoOpenFileErrorBox});
{$ENDIF}
  DLLHandle := LoadLibrary('NEROPACKETWRITING.DLL');
  if DLLHandle >= 32 then
  begin
    DLLLoaded := True;
    SaveExit := ExitProc;
    ExitProc := @NewExit;
    @mode := GetProcAddress(DLLHandle,'mode');
  {$IFDEF WIN32}
    Assert(@mode <> nil);
  {$ENDIF}
    @NeroCreateBlockWriterInterface := GetProcAddress(DLLHandle,'NeroCreateBlockWriterInterface');
  {$IFDEF WIN32}
    Assert(@NeroCreateBlockWriterInterface <> nil);
  {$ENDIF}
    @NeroCreateBlockReaderInterface := GetProcAddress(DLLHandle,'NeroCreateBlockReaderInterface');
  {$IFDEF WIN32}
    Assert(@NeroCreateBlockReaderInterface <> nil);
  {$ENDIF}
    @NeroCreateBlockAccessFromImage := GetProcAddress(DLLHandle,'NeroCreateBlockAccessFromImage');
  {$IFDEF WIN32}
    Assert(@NeroCreateBlockAccessFromImage <> nil);
  {$ENDIF}
    @NeroGetSupportedAccessModesForDevice := GetProcAddress(DLLHandle,'NeroGetSupportedAccessModesForDevice');
  {$IFDEF WIN32}
    Assert(@NeroGetSupportedAccessModesForDevice <> nil);
  {$ENDIF}
  end
  else
  begin
    DLLLoaded := False;
    { Error: NEROPACKETWRITING.DLL could not be loaded !! }
  end;
{$IFNDEF MSDOS}
  SetErrorMode(ErrorMode)
{$ENDIF}
end {LoadDLL};

begin
  LoadDLL;
end.
