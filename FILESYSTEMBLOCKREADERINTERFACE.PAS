unit FILESYSTEMBLOCKREADERINTERFACE;
{**************************************************************************}
{                                                                          }
{    This C DLL header file first (automatic) conversion generated by:     }
{    HeadConv 4.0 (c) 2000 by Bob Swart (aka Dr.Bob - www.drbob42.com)     }
{      Final Delphi-Jedi (Darth) command-line units edition                }
{                                                                          }
{    Generated Date: 02/06/2003                                            }
{    Generated Time: 11:12:05                                              }
{                                                                          }
{**************************************************************************}

interface
uses
{$IFDEF WIN32}
  Windows;
{$ELSE}
  Wintypes, WinProcs;
{$ENDIF}


{=> NeroFileSystemManager\FILESYSTEMBLOCKREADERINTERFACE.H <=}

{+//***************************************************************************** }
{-|* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF }
{-|* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO }
{-|* THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A }
{-|* PARTICULAR PURPOSE. }
{-|* }
{-|* Copyright 1995-2003 Ahead Software AG. All Rights Reserved. }
{-|*----------------------------------------------------------------------------- }
{-|* NeroSDK / NeroAPI }
{-|* }
{-|* PROGRAM: FileSystemBlockReaderInterface.h }
{-|* }
{-|* PURPOSE: This file contains an abstract interface for reading from block }
{-|* devices. It will provide necessary data about the underlying }
{-|* medium as well as cache data if necessary. }
{=***************************************************************************** }
{$IFNDEF FILESYSTEMBLOCKREADERINTERFACE_H}
{$DEFINE FILESYSTEMBLOCKREADERINTERFACE_H}


{$INCLUDE <windows.h>}

type
  NeroFSSecNo = __INT64;

type
  NeroFSPartitionInfo = (
    errOK{=0}, 
    errEndOfDir, 
    errEndOfFile, 
    errReadError, 
    errInvalidFS, 
    errNoDirectory, 
    errNoFile, 
    errNotSupported, 
    errIllegalArgument, 
    errWriteError, 
    errInternalError, 
    errFileLocked  );


type
  NeroFSPartitionInfo = (
    vtData{=0}, 
    vtAudio  );

type
  NeroFSPartitionInfo = record
    PartitionNum: Integer;
    PartitionStart: NEROFSSECNO;
    PartitionSize: NEROFSSECNO;
    PartitionType: NEROFSTRACKTYPE;
    sectorSize: LongInt;
  end {NeroFSPartitionInfo};

var
  GetNumPartitions: function: PUBLIC: VIRTUAL INT cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  &GetPartitionInfo: function(iNumPartition: Integer): VIRTUAL CONST cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 

{/// Returns the partition a given sector resides in }
var
  &GetPartitionForSector: function(secNo: NEROFSSECNO): VIRTUAL CONST cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 

{/// Reading methods. The Buffered varient will use a cache to optimize filesystem access. }
{/// It should be used when reading directory structures while the UnBuffered method should be }
{/// used when reading file contents }
{/// Both methods return error codes as described in NeroFSError }
{/// Your read requests may not cross partition boundaries! }
var
  ReadSectorsBuffered: function(pData: Pointer; 
                                startSector: NEROFSSECNO; 
                                noSectors: NEROFSSECNO; 
                                var noSectorsRead: NEROFSSECNO): VIRTUAL cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  ReadSectorsUnBuffered: function(pData: Pointer; 
                                  startSector: NEROFSSECNO; 
                                  noSectors: NEROFSSECNO; 
                                  var noSectorsRead: NEROFSSECNO): VIRTUAL cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 

var
  ~INeroFileSystemBlockReader: function: VIRTUAL cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 

{$ENDIF // FILESYSTEMBLOCKREADERINTERFACE_H}

var
  DLLLoaded: Boolean { is DLL (dynamically) loaded already? }
    {$IFDEF WIN32} = False; {$ENDIF}

implementation

var
  SaveExit: pointer;
  DLLHandle: THandle;
{$IFNDEF MSDOS}
  ErrorMode: Integer;
{$ENDIF}

  procedure NewExit; far;
  begin
    ExitProc := SaveExit;
    FreeLibrary(DLLHandle)
  end {NewExit};

procedure LoadDLL;
begin
  if DLLLoaded then Exit;
{$IFNDEF MSDOS}
  ErrorMode := SetErrorMode($8000{SEM_NoOpenFileErrorBox});
{$ENDIF}
  DLLHandle := LoadLibrary('FILESYSTEMBLOCKREADERINTERFACE.DLL');
  if DLLHandle >= 32 then
  begin
    DLLLoaded := True;
    SaveExit := ExitProc;
    ExitProc := @NewExit;
    @GetNumPartitions := GetProcAddress(DLLHandle,'GetNumPartitions');
  {$IFDEF WIN32}
    Assert(@GetNumPartitions <> nil);
  {$ENDIF}
    @&GetPartitionInfo := GetProcAddress(DLLHandle,'&GetPartitionInfo');
  {$IFDEF WIN32}
    Assert(@&GetPartitionInfo <> nil);
  {$ENDIF}
    @&GetPartitionForSector := GetProcAddress(DLLHandle,'&GetPartitionForSector');
  {$IFDEF WIN32}
    Assert(@&GetPartitionForSector <> nil);
  {$ENDIF}
    @ReadSectorsBuffered := GetProcAddress(DLLHandle,'ReadSectorsBuffered');
  {$IFDEF WIN32}
    Assert(@ReadSectorsBuffered <> nil);
  {$ENDIF}
    @ReadSectorsUnBuffered := GetProcAddress(DLLHandle,'ReadSectorsUnBuffered');
  {$IFDEF WIN32}
    Assert(@ReadSectorsUnBuffered <> nil);
  {$ENDIF}
    @~INeroFileSystemBlockReader := GetProcAddress(DLLHandle,'~INeroFileSystemBlockReader');
  {$IFDEF WIN32}
    Assert(@~INeroFileSystemBlockReader <> nil);
  {$ENDIF}
  end
  else
  begin
    DLLLoaded := False;
    { Error: FILESYSTEMBLOCKREADERINTERFACE.DLL could not be loaded !! }
  end;
{$IFNDEF MSDOS}
  SetErrorMode(ErrorMode)
{$ENDIF}
end {LoadDLL};

begin
  LoadDLL;
end.
