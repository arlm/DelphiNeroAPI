unit NEROISOTRACK;
{**************************************************************************}
{                                                                          }
{    This C DLL header file first (automatic) conversion generated by:     }
{    HeadConv 4.0 (c) 2000 by Bob Swart (aka Dr.Bob - www.drbob42.com)     }
{      Final Delphi-Jedi (Darth) command-line units edition                }
{                                                                          }
{    Generated Date: 02/06/2003                                            }
{    Generated Time: 11:10:45                                              }
{                                                                          }
{**************************************************************************}

interface
uses
{$IFDEF WIN32}
  Windows;
{$ELSE}
  Wintypes, WinProcs;
{$ENDIF}


{=> NEROISOTRACK.H <=}

{+//***************************************************************************** }
{-|* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF }
{-|* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO }
{-|* THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A }
{-|* PARTICULAR PURPOSE. }
{-|* }
{-|* Copyright 1995-2003 Ahead Software AG. All Rights Reserved. }
{-|*----------------------------------------------------------------------------- }
{-|* NeroSDK / NeroAPI }
{-|* }
{-|* PROGRAM: NeroIsoTrack.h }
{-|* }
{-|* PURPOSE: Classes for writing ISO 9660/Joliet track }
{-|* }
{-|* NOTE: In contrast to NeroAPI.h, this code is not pure C, but rather C++ }
{=***************************************************************************** }


{$IFNDEF _NEROISOTRACK_}
{$DEFINE _NEROISOTRACK_}

{$INCLUDE "NeroAPI.h"}

{$IFNDEF __cplusplus}

{ #error The Nero ISO Track feature can only be used by C++ code. }

{$ELSE /* __cplusplus*/}

{$IFNDEF NEROAPI_PORTABLE}
{$INCLUDE <windows.h> // the data types used below are those of windows}
{$ELSE}
{$INCLUDE <iostream>}
{$INCLUDE "datatypes.h"}
{$ENDIF}

{/// }
{/// The application has to specify the complete layout of the }
{/// ISO track. The NeroAPI does not care at all where the }
{/// data for the files comes from. This also means that the }
{/// application has to provide access to the filename or the }
{/// data itself when the API needs it. }
{/// }

{/// }
{/// Data can be fed into the API directly (i.e. without intermediate }
{/// files) with CNeroDataCallback: }
{/// }
var
  ~CNeroDataCallback: var function: UBLIC: VIRTUAL cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 

var
  IOCallback: function(var pBuffer: BYTE; 
                       dwLen: LongInt): VIRTUAL cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  EOFCallback: function: VIRTUAL cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  ErrorCallback: function: VIRTUAL cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 

{/// }
{/// The API builds an internal representation of the complete }
{/// ISO tree and uses a CNeroIsoHandle acquired from the }
{/// application for each file to access the data later. }
{/// Usually only one file at once will be left open. }
{/// }
var
  ~CNeroIsoHandle: var function: UBLIC: VIRTUAL cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  Clone: var function: VIRTUAL CNEROISOHANDLE cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 

var
  GetFileName: function(strBuffer: PChar; 
                        nBufferSize: Word): VIRTUAL cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
{/// the buffer of size nBufferSize with a null-terminated string and return }
{/// the length of the full name, even if the given buffer was to small. }
{/// The API will try again with a larger buffer then. }

{/// return 0 in GetFileName() if you want to provide the data via a CNeroDataCallback: }
var
  Open: var function: VIRTUAL CNERODATACALLBACK cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
{/// this instance will be deleted by NeroAPI; }
{/// usually only one file at once will be left open }

{/// }
{/// Iterators are used to walk through directories while the API builds }
{/// its internal copy of the tree. Iterators point to an entry or to NULL, }
{/// if the last entry was passed, and can only be incremented. }
{/// }
var
  ~CNeroIsoIterator: var function: UBLIC: VIRTUAL cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 

var
  GetCurrentEntry: var function: VIRTUAL CNEROISOENTRY cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
{/// entry not deleted by API, so the iterator may point to itself }
{/// and implement the required interface (as in the NeroAPI demo), }
{/// or to some permanent entry }
var
  Next: function cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 

{/// }
{/// An entry (directory or file) is described like this: }
{/// }
type
  CImportInfo; = record
      end {CImportInfo;};
var
  CreateDirectoryIterator: function: PVIRTUAL CNEROISOITERATOR cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
{/// iterator will be deleted by NeroAPI }

var
  GetName: var function: VIRTUAL CONST CHAR cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  GetLength: function: VIRTUAL cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  CreateHandle: var function: VIRTUAL CNEROISOHANDLE cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
{/// handle will be deleted by NeroAPI when deleting the internal ISO tree }

{/// The following entries are only needed when e.g. creating your }
{/// own Video CD ISO track and not implemented yet. }
{$IFDEF 0}
var
  IsMode2: function: VIRTUAL cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
{/// NOTE: the size above are the number of bytes delivered by the application }
{/// NOTE to ahead implementor: in contrast, the ISO entry length always assumes a }
{/// lock size of 2048 and thus GetSize() has to be multiplied by 2048/2336 before using it as CIsoListEntry::size }
var
  GetBlockOffset: function: VIRTUAL cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
{/// or in a block chosen by NeroAPI if -1 }
{$ENDIF}

{/// Can be used to reference files from previous session }
var
  GetDataStartSec: function: VIRTUAL cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  IsDataFixed: function: VIRTUAL cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  GetEntryTime: function(var tm: TM): VIRTUAL cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
{/// This method was formerly known as GetRockRidgeInfo. }
{/// The object returned is a bit different internally now. }
{/// Since it is a private structure of NeroAPI this change doesn't matter. }
var
  GetImportInfo: var function: VIRTUAL CIMPORTINFO cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
{/// no ImportInfo by default }
var
  GetPriorities: function(var iPriority: Integer; 
                          var iDirPriority: Integer) cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
{/// Up from NeroAPI 5.5.9.0 }
var
  CreateDirectoryIteratorWrapper: var function: VIRTUAL CNEROISOITERATOR cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
{/// See CreateHandle(). Creates rsc fork handle for HFS filesystems }
{/// Will be preferred to reading the resource fork from the file specified by GetName() if !=NULL }
var
  CreateResourceHandle: var function: VIRTUAL CNEROISOHANDLE cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  reserved1: function: VIRTUAL cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  reserved2: function: VIRTUAL cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  reserved3: function: VIRTUAL cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  reserved4: function: VIRTUAL cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  reserved5: function: VIRTUAL cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  reserved6: function: VIRTUAL cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  reserved7: function: VIRTUAL cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  reserved8: function: VIRTUAL cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  reserved9: function: VIRTUAL cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 


{/// }
{/// An ISO track is a special directory entry: }
{/// }
type
  CNeroIsoTrack : public CNeroIsoEntry = record
    CNeroIsoTrackProxy5039: FRIEND CLASS;
    CNeroIsoTrackProxy55915: FRIEND CLASS;
      end {CNeroIsoTrack : public CNeroIsoEntry};
{/// essential functions: }
var
  GetName: function: PVIRTUAL CONST CHAR cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  CreateDirectoryIterator: var function: VIRTUAL CNEROISOITERATOR cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 

{/// these new functions have reasonable defaults: }
var
  UseJoliet: function: VIRTUAL cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  UseMode2: function: VIRTUAL cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 

{/// The following 3 functions exist from NeroAPI version 5.5.0.0 }
var
  UseRockRidge: function: VIRTUAL cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  BurnISO: function: VIRTUAL cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  BurnUDF: function: VIRTUAL cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 

var
  GetLength: var function: ROTECTED: VIRTUAL __INT64 cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  CreateHandle: var function: VIRTUAL CNEROISOHANDLE cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  CreateResourceHandle: var function: VIRTUAL CNEROISOHANDLE cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 

{/// You can set your burn options simply be redefining this function instead of }
{/// UseJoliet, UseMode2, UseRockRidge, BurnISO and BurnUDF }
{/// See NeroAPI.h for the signification of the NCITEF flags }
var
  BurnOptions: function: VIRTUAL cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  return: function(0: USEJOLIET() ? NCITEF_USE_JOLIET : 0) |(USEMODE2() ? NCITEF_USE_MODE2 : 0) |(USEROCKRIDGE() ? NCITEF_USE_ROCKRIDGE : 0) |(BURNISO() ? NCITEF_CREATE_ISO_FS : 0) |(BURNUDF() ? NCITEF_CREATE_UDF_FS :): Integer cdecl  {$IFDEF WIN32} std

{/// Up from NeroAPI 5.5.9.0 }
var
  CreateDirectoryIteratorWrapper: var function: VIRTUAL CNEROISOITERATOR cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 

var
  HasWrapper: function: VIRTUAL cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 

{/// for internal use only. Do not reimplement this method! }
var
  dummy: function cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 

var
  GetVolumeDescriptor: function(const systemIdentifier: PPChar; 
                                const volumeSet: PPChar; 
                                const publisher: PPChar; 
                                const dataPreparer: PPChar; 
                                const application: PPChar; 
                                const copyright: PPChar; 
                                const abstract: PPChar; 
                                const bibliographic: PPChar) cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 


{/// Reserved for future use }
var
  reserved1: function: VIRTUAL cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  reserved2: function: VIRTUAL cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  reserved3: function: VIRTUAL cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  reserved4: function: VIRTUAL cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  reserved5: function: VIRTUAL cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  reserved6: function: VIRTUAL cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  reserved7: function: VIRTUAL cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  reserved8: function: VIRTUAL cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 


{$ENDIF /* __cplusplus*/}


{$ENDIF /* _NEROISOTRACK_*/}

var
  DLLLoaded: Boolean { is DLL (dynamically) loaded already? }
    {$IFDEF WIN32} = False; {$ENDIF}

implementation

var
  SaveExit: pointer;
  DLLHandle: THandle;
{$IFNDEF MSDOS}
  ErrorMode: Integer;
{$ENDIF}

  procedure NewExit; far;
  begin
    ExitProc := SaveExit;
    FreeLibrary(DLLHandle)
  end {NewExit};

procedure LoadDLL;
begin
  if DLLLoaded then Exit;
{$IFNDEF MSDOS}
  ErrorMode := SetErrorMode($8000{SEM_NoOpenFileErrorBox});
{$ENDIF}
  DLLHandle := LoadLibrary('NEROISOTRACK.DLL');
  if DLLHandle >= 32 then
  begin
    DLLLoaded := True;
    SaveExit := ExitProc;
    ExitProc := @NewExit;
    @~CNeroDataCallback := GetProcAddress(DLLHandle,'~CNeroDataCallback');
  {$IFDEF WIN32}
    Assert(@~CNeroDataCallback <> nil);
  {$ENDIF}
    @IOCallback := GetProcAddress(DLLHandle,'IOCallback');
  {$IFDEF WIN32}
    Assert(@IOCallback <> nil);
  {$ENDIF}
    @EOFCallback := GetProcAddress(DLLHandle,'EOFCallback');
  {$IFDEF WIN32}
    Assert(@EOFCallback <> nil);
  {$ENDIF}
    @ErrorCallback := GetProcAddress(DLLHandle,'ErrorCallback');
  {$IFDEF WIN32}
    Assert(@ErrorCallback <> nil);
  {$ENDIF}
    @~CNeroIsoHandle := GetProcAddress(DLLHandle,'~CNeroIsoHandle');
  {$IFDEF WIN32}
    Assert(@~CNeroIsoHandle <> nil);
  {$ENDIF}
    @Clone := GetProcAddress(DLLHandle,'Clone');
  {$IFDEF WIN32}
    Assert(@Clone <> nil);
  {$ENDIF}
    @GetFileName := GetProcAddress(DLLHandle,'GetFileName');
  {$IFDEF WIN32}
    Assert(@GetFileName <> nil);
  {$ENDIF}
    @Open := GetProcAddress(DLLHandle,'Open');
  {$IFDEF WIN32}
    Assert(@Open <> nil);
  {$ENDIF}
    @~CNeroIsoIterator := GetProcAddress(DLLHandle,'~CNeroIsoIterator');
  {$IFDEF WIN32}
    Assert(@~CNeroIsoIterator <> nil);
  {$ENDIF}
    @GetCurrentEntry := GetProcAddress(DLLHandle,'GetCurrentEntry');
  {$IFDEF WIN32}
    Assert(@GetCurrentEntry <> nil);
  {$ENDIF}
    @Next := GetProcAddress(DLLHandle,'Next');
  {$IFDEF WIN32}
    Assert(@Next <> nil);
  {$ENDIF}
    @CreateDirectoryIterator := GetProcAddress(DLLHandle,'CreateDirectoryIterator');
  {$IFDEF WIN32}
    Assert(@CreateDirectoryIterator <> nil);
  {$ENDIF}
    @GetName := GetProcAddress(DLLHandle,'GetName');
  {$IFDEF WIN32}
    Assert(@GetName <> nil);
  {$ENDIF}
    @GetLength := GetProcAddress(DLLHandle,'GetLength');
  {$IFDEF WIN32}
    Assert(@GetLength <> nil);
  {$ENDIF}
    @CreateHandle := GetProcAddress(DLLHandle,'CreateHandle');
  {$IFDEF WIN32}
    Assert(@CreateHandle <> nil);
  {$ENDIF}
    @IsMode2 := GetProcAddress(DLLHandle,'IsMode2');
  {$IFDEF WIN32}
    Assert(@IsMode2 <> nil);
  {$ENDIF}
    @GetBlockOffset := GetProcAddress(DLLHandle,'GetBlockOffset');
  {$IFDEF WIN32}
    Assert(@GetBlockOffset <> nil);
  {$ENDIF}
    @GetDataStartSec := GetProcAddress(DLLHandle,'GetDataStartSec');
  {$IFDEF WIN32}
    Assert(@GetDataStartSec <> nil);
  {$ENDIF}
    @IsDataFixed := GetProcAddress(DLLHandle,'IsDataFixed');
  {$IFDEF WIN32}
    Assert(@IsDataFixed <> nil);
  {$ENDIF}
    @GetEntryTime := GetProcAddress(DLLHandle,'GetEntryTime');
  {$IFDEF WIN32}
    Assert(@GetEntryTime <> nil);
  {$ENDIF}
    @GetImportInfo := GetProcAddress(DLLHandle,'GetImportInfo');
  {$IFDEF WIN32}
    Assert(@GetImportInfo <> nil);
  {$ENDIF}
    @GetPriorities := GetProcAddress(DLLHandle,'GetPriorities');
  {$IFDEF WIN32}
    Assert(@GetPriorities <> nil);
  {$ENDIF}
    @CreateDirectoryIteratorWrapper := GetProcAddress(DLLHandle,'CreateDirectoryIteratorWrapper');
  {$IFDEF WIN32}
    Assert(@CreateDirectoryIteratorWrapper <> nil);
  {$ENDIF}
    @CreateResourceHandle := GetProcAddress(DLLHandle,'CreateResourceHandle');
  {$IFDEF WIN32}
    Assert(@CreateResourceHandle <> nil);
  {$ENDIF}
    @reserved1 := GetProcAddress(DLLHandle,'reserved1');
  {$IFDEF WIN32}
    Assert(@reserved1 <> nil);
  {$ENDIF}
    @reserved2 := GetProcAddress(DLLHandle,'reserved2');
  {$IFDEF WIN32}
    Assert(@reserved2 <> nil);
  {$ENDIF}
    @reserved3 := GetProcAddress(DLLHandle,'reserved3');
  {$IFDEF WIN32}
    Assert(@reserved3 <> nil);
  {$ENDIF}
    @reserved4 := GetProcAddress(DLLHandle,'reserved4');
  {$IFDEF WIN32}
    Assert(@reserved4 <> nil);
  {$ENDIF}
    @reserved5 := GetProcAddress(DLLHandle,'reserved5');
  {$IFDEF WIN32}
    Assert(@reserved5 <> nil);
  {$ENDIF}
    @reserved6 := GetProcAddress(DLLHandle,'reserved6');
  {$IFDEF WIN32}
    Assert(@reserved6 <> nil);
  {$ENDIF}
    @reserved7 := GetProcAddress(DLLHandle,'reserved7');
  {$IFDEF WIN32}
    Assert(@reserved7 <> nil);
  {$ENDIF}
    @reserved8 := GetProcAddress(DLLHandle,'reserved8');
  {$IFDEF WIN32}
    Assert(@reserved8 <> nil);
  {$ENDIF}
    @reserved9 := GetProcAddress(DLLHandle,'reserved9');
  {$IFDEF WIN32}
    Assert(@reserved9 <> nil);
  {$ENDIF}
    @GetName := GetProcAddress(DLLHandle,'GetName');
  {$IFDEF WIN32}
    Assert(@GetName <> nil);
  {$ENDIF}
    @CreateDirectoryIterator := GetProcAddress(DLLHandle,'CreateDirectoryIterator');
  {$IFDEF WIN32}
    Assert(@CreateDirectoryIterator <> nil);
  {$ENDIF}
    @UseJoliet := GetProcAddress(DLLHandle,'UseJoliet');
  {$IFDEF WIN32}
    Assert(@UseJoliet <> nil);
  {$ENDIF}
    @UseMode2 := GetProcAddress(DLLHandle,'UseMode2');
  {$IFDEF WIN32}
    Assert(@UseMode2 <> nil);
  {$ENDIF}
    @UseRockRidge := GetProcAddress(DLLHandle,'UseRockRidge');
  {$IFDEF WIN32}
    Assert(@UseRockRidge <> nil);
  {$ENDIF}
    @BurnISO := GetProcAddress(DLLHandle,'BurnISO');
  {$IFDEF WIN32}
    Assert(@BurnISO <> nil);
  {$ENDIF}
    @BurnUDF := GetProcAddress(DLLHandle,'BurnUDF');
  {$IFDEF WIN32}
    Assert(@BurnUDF <> nil);
  {$ENDIF}
    @GetLength := GetProcAddress(DLLHandle,'GetLength');
  {$IFDEF WIN32}
    Assert(@GetLength <> nil);
  {$ENDIF}
    @CreateHandle := GetProcAddress(DLLHandle,'CreateHandle');
  {$IFDEF WIN32}
    Assert(@CreateHandle <> nil);
  {$ENDIF}
    @CreateResourceHandle := GetProcAddress(DLLHandle,'CreateResourceHandle');
  {$IFDEF WIN32}
    Assert(@CreateResourceHandle <> nil);
  {$ENDIF}
    @BurnOptions := GetProcAddress(DLLHandle,'BurnOptions');
  {$IFDEF WIN32}
    Assert(@BurnOptions <> nil);
  {$ENDIF}
    @return := GetProcAddress(DLLHandle,'return');
  {$IFDEF WIN32}
    Assert(@return <> nil);
  {$ENDIF}
    @CreateDirectoryIteratorWrapper := GetProcAddress(DLLHandle,'CreateDirectoryIteratorWrapper');
  {$IFDEF WIN32}
    Assert(@CreateDirectoryIteratorWrapper <> nil);
  {$ENDIF}
    @HasWrapper := GetProcAddress(DLLHandle,'HasWrapper');
  {$IFDEF WIN32}
    Assert(@HasWrapper <> nil);
  {$ENDIF}
    @dummy := GetProcAddress(DLLHandle,'dummy');
  {$IFDEF WIN32}
    Assert(@dummy <> nil);
  {$ENDIF}
    @GetVolumeDescriptor := GetProcAddress(DLLHandle,'GetVolumeDescriptor');
  {$IFDEF WIN32}
    Assert(@GetVolumeDescriptor <> nil);
  {$ENDIF}
    @reserved1 := GetProcAddress(DLLHandle,'reserved1');
  {$IFDEF WIN32}
    Assert(@reserved1 <> nil);
  {$ENDIF}
    @reserved2 := GetProcAddress(DLLHandle,'reserved2');
  {$IFDEF WIN32}
    Assert(@reserved2 <> nil);
  {$ENDIF}
    @reserved3 := GetProcAddress(DLLHandle,'reserved3');
  {$IFDEF WIN32}
    Assert(@reserved3 <> nil);
  {$ENDIF}
    @reserved4 := GetProcAddress(DLLHandle,'reserved4');
  {$IFDEF WIN32}
    Assert(@reserved4 <> nil);
  {$ENDIF}
    @reserved5 := GetProcAddress(DLLHandle,'reserved5');
  {$IFDEF WIN32}
    Assert(@reserved5 <> nil);
  {$ENDIF}
    @reserved6 := GetProcAddress(DLLHandle,'reserved6');
  {$IFDEF WIN32}
    Assert(@reserved6 <> nil);
  {$ENDIF}
    @reserved7 := GetProcAddress(DLLHandle,'reserved7');
  {$IFDEF WIN32}
    Assert(@reserved7 <> nil);
  {$ENDIF}
    @reserved8 := GetProcAddress(DLLHandle,'reserved8');
  {$IFDEF WIN32}
    Assert(@reserved8 <> nil);
  {$ENDIF}
  end
  else
  begin
    DLLLoaded := False;
    { Error: NEROISOTRACK.DLL could not be loaded !! }
  end;
{$IFNDEF MSDOS}
  SetErrorMode(ErrorMode)
{$ENDIF}
end {LoadDLL};

begin
  LoadDLL;
end.
